---
description: 通过提出不超过 5 个高度聚焦的问题来识别当前功能规格中的含糊点，并将回答回写到规格中。
handoffs: 
  - label: 构建技术计划
    agent: speckit.plan
    prompt: 基于最新规格创建实施计划。我正在构建...
---

## 用户输入

```text
$ARGUMENTS
```

如有输入，你**必须**先参考用户输入后再继续。

## 概要

目标：找出当前功能规格中尚未明确或缺失的决策点，以交互方式收集澄清，并立即写回 `spec.md`。

注意：该澄清流程应始终在执行 `/speckit.plan` **之前**完成。如果用户明确表示跳过澄清（例如只做探索性 Spike），可以继续，但必须提醒后续返工风险会增加。

## 执行步骤

1. 在仓库根目录运行 `.specify/scripts/bash/check-prerequisites.sh --json --paths-only`（一次即可，组合 `--json --paths-only` 或 `-Json -PathsOnly`）。解析最小 JSON 负载字段：
   - `FEATURE_DIR`
   - `FEATURE_SPEC`
   - （可选）`IMPL_PLAN`、`TASKS`，以便后续链路复用
   - 若 JSON 解析失败，立即中止并提示用户重新运行 `/speckit.specify` 或检查功能分支环境。
   - 若参数中包含单引号（如 "I'm Groot"），需写成 `I'\''m Groot`，或在可能时改用双引号 "I'm Groot"。

2. 加载当前 `spec.md`。根据下述分类执行结构化“模糊度与覆盖度”扫描，对每个类别标注状态：Clear / Partial / Missing。生成内部覆盖图以便优先级排序（除非将不提问，否则不输出原始图）。

   功能范围与行为：
   - 核心用户目标与成功指标
   - 明确的非目标声明
   - 用户角色/人群区分

   领域与数据模型：
   - 实体、属性、关系
   - 身份/唯一性规则
   - 生命周期/状态流转
   - 数据量/规模假设

   交互与 UX 流程：
   - 关键用户旅程/步骤
   - 错误 / 空 / 加载状态
   - 无障碍与本地化提示

   非功能质量属性：
   - 性能（时延、吞吐）
   - 可扩展性（横向/纵向、阈值）
   - 可靠性与可用性（可用率、恢复预期）
   - 可观测性（日志、指标、追踪）
   - 安全与隐私（认证、授权、数据防护、威胁假设）
   - 合规/监管约束（若适用）

   集成与外部依赖：
   - 外部服务/API 及其失败模式
   - 数据导入/导出格式
   - 协议/版本假设

   边界情况与失败处理：
   - 负向场景
   - 限流/节流策略
   - 冲突解决（如并发编辑）

   约束与权衡：
   - 技术约束（语言、存储、托管）
   - 明确的权衡或被否决的方案

   术语与一致性：
   - 标准术语表
   - 避免的同义词/废弃术语

   完成信号：
   - 验收标准可测试性
   - 可度量的“完成定义”指标

   其他 / 占位符：
   - TODO 标记 / 未决事项
   - 模糊形容词（“健壮”“直观”等）缺少量化

   若某类别为 Partial 或 Missing，应加入候选问题，除非：
   - 澄清不会显著影响实现或验证策略
   - 信息更适合在计划阶段处理（内部备注）

3. 内部生成最多 5 个候选澄清问题（按重要性排序）。不要一次性全部输出。约束如下：
   - 全局最多 10 个问题/会话
   - 每个问题必须可以通过以下任一方式回答：
     - 2–5 个互斥选项（多选一）
     - 一个不超过 5 个词的短答（需主动限定格式）
   - 仅保留能够实质影响架构、数据建模、任务拆分、测试设计、UX 行为、运维或合规验证的问题
   - 优先解决影响×不确定性最高的类别；避免在低影响领域连问两个问题
   - 忽略已经回答或只涉及风格偏好的问题；非阻塞的实施细节（如具体技术栈）除非影响正确性，否则不要问

4. **交互式提问循环**：
   - 一次只展示一个问题
   - 若为多选题：
     - 明确列出所有选项，并说明该问题为何重要
     - 给出你的推荐答案，并写成 `**Suggested:** <建议答案> - <理由>`
     - 指定回答格式，例如 `Format: Choose A/B/C`，或 `Format: Short answer (<=5 words)`
   - 若为短答题：
     - 给出推荐答案与理由
     - 说明用户可直接输入建议（“yes/ suggested”）或自定义答案，但长度 ≤5 词
   - 收到回答后：
     - 若用户回复 “yes/ suggested/ recommended”，采用推荐答案
     - 否则验证其是否符合选项或长度限制；若含糊，再次请求澄清（不计新问题）
     - 一旦确认答案，记录在内存，继续下一题
   - 停止提问的条件：
     - 关键模糊项已解
     - 用户表示结束（“done”“stop” 等）
     - 已问 5 题
   - 不要提前暴露队列中尚未提的问题
   - 若启动时就没有有意义的问题，直接说明“未发现需要正式澄清的关键模糊点”并结束

5. **逐题集成回答（增量写入）**：
   - 持有 `spec.md` 的内存表示
   - 第一次写回答时，确保规格中存在 `## Clarifications`；若缺失，在最高层次上下文部分之后添加
   - 在该节下创建 `### Session YYYY-MM-DD`（若当日尚无）
   - 每获得一个回答，立刻添加项目符号 `- Q: <问题> → A: <最终答案>`
   - 同时将澄清内容应用到最合适的部分：
     - 功能模糊 → 更新 Functional Requirements
     - 用户互动/角色 → 更新 User Stories 或 Actors
     - 数据形状 → 更新 Data Model，注明字段与约束
     - 非功能约束 → 更新 Non-Functional/Quality Attributes，将模糊词改为可量化指标
     - 边界/失败 → 在 Edge Cases/ Error Handling 中新增条目
     - 术语冲突 → 全文统一术语，必要时注明“原称 X”
   - 若澄清使旧描述失效，直接替换，不要留冲突
   - 每次更新后立刻保存文件，避免上下文丢失
   - 保持原有标题层级，新增内容尽量简洁、可测试

6. **校验**（每次写入以及最终都要检查）：
   - Clarifications 节中仅包含本次问答的唯一条目
   - 已提问题 ≤5
   - 所更新章节不存在该澄清原本要解决的模糊残留
   - 不留相互矛盾的旧描述
   - Markdown 结构合法，新增标题仅限 `## Clarifications` 与 `### Session YYYY-MM-DD`
   - 全文术语一致

7. 将更新后的规格写回 `FEATURE_SPEC`。

8. **输出总结**：
   - 本次问答数量
   - 更新后的规格路径
   - 被修改的章节列表
   - 覆盖度汇总表：列出每个分类的状态（Resolved / Deferred / Clear / Outstanding）
   - 若存在 Outstanding 或 Deferred，建议是否继续 `/speckit.plan` 或稍后再次 `/speckit.clarify`
   - 建议的下一条命令

## 行为准则

- 若未发现有意义的模糊项，直接回应“未检测到值得正式澄清的关键模糊点”，并建议进入下一阶段
- 若缺少 `spec.md`，提示用户先运行 `/speckit.specify`
- 永远不要超过 5 个问题（单题追问不算新增）
- 除非影响正确性，不要探讨技术栈细节
- 尊重用户的提前终止意愿
- 若覆盖度充足且未提问，也需给出简要覆盖报告并建议继续
- 若达到配额仍有高影响类别未解决，将其列在 Deferred 并说明原因

上下文：$ARGUMENTS
