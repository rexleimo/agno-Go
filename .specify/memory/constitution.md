<!--
版本变更：2.0.0 → 2.1.0
被修改的原则：
- 新增：Go 原生实现与运行时独立
新增章节：
- Go 原生实现与运行时独立
移除章节：
- 无
模板同步：
- ✅ .specify/templates/plan-template.md
- ✅ .specify/templates/spec-template.md
- ✅ .specify/templates/tasks-template.md
- ⚠️ .specify/templates/commands/（目录仍不存在，无文件可同步）
未完成的 TODO：
- 无
-->
# Agno-Go 宪章

## 项目使命与范围

- 本仓库的使命是为 Python 项目 `./agno` 中的 Agno 框架提供高质量、可维护的 Go 语言实现，使核心能力（Agents、Teams、Workflows、AgentOS 等）在 Go 中具备与 Python 版本尽可能一致的行为与开发体验。
- Python 代码库（`./agno/libs/agno/agno/` 及其 tests）是事实规范：Go 实现必须以其公开行为、文档和测试为主要参考，而不是随意自创不兼容语义。
- Go 版本应服务于以下目标：
  - 为追求性能、静态类型和简化部署的团队提供一流体验；
  - 在关键抽象（Agent、Tool、Memory、Knowledge、Workflow 等）上保持与 Python 版本概念上的一致性；
  - 通过契约测试与文档确保两种语言实现可以互相作为示例和规范。
- Go 实现必须完全由 Go 代码交付，禁止在运行时调用 `./agno` 或任何 Python 模块；`./agno` 仓库仅作为行为参考与测试数据来源，跨语言桥接只能存在于开发脚本或测试工具中。

## 核心原则

### Python 参考实现与行为对齐

- Python 实现是功能与语义的首要参考源：任何 Go 功能都必须在 Python 侧找到对应模块、类或 API，或者在规格中明确说明差异与理由。
- 当 Python 版本新增能力时，必须在规格和计划中记录该能力是否需要 Go 侧跟进，以及跟进优先级；禁止在没有说明的情况下让两边语义长期漂移。
- 行为对齐以可观察行为为准（函数输入输出、错误类型/状态、事件序列等），而不是逐行翻译实现细节；Go 实现可以采用不同算法或数据结构，但不得改变对外契约。
- 若 Go 侧出于性能或安全考虑需要偏离 Python 行为，必须在 spec/plan 中记录偏离点、理由以及对调用方的影响，并为此新增或更新测试与文档。

### Go 原生实现与运行时独立

- Go 代码库必须在无 Python 依赖的环境中通过 `go build ./...` 与 `go test ./...`，任何导出的包都不得通过 cgo、`os/exec` 或内嵌解释器调用 `./agno` Python 代码。
- 允许为契约测试或基准测试使用 Python–Go 桥接（例如 CLI、JSON fixture、gRPC 服务），但这些桥接必须位于 `scripts/`、`specs/` 或测试目录中，并明确标注为对照工具，禁止由最终库或可发布产物引用。
- 如在迁移初期需要临时依赖 Python 来验证行为，计划中必须标记清理任务与退出条件，并在交付前移除该依赖；若无法在本迭代清理，需在任务中记录 BLOCKED 原因与解法。

### Go API 设计与包结构

- Go 源码必须采用清晰、可预期的包结构，将 Python 中的核心模块（如 `agent`、`team`、`workflow`、`memory`、`knowledge`、`models`、`tools`、`os` 等）映射到 Go 包（例如 `agent`、`team`、`workflow`、`memory`、`knowledge`、`models`、`tools`、`os` 等），避免杂乱或高度耦合的 “utils” 包。
- Go API 设计 MUST 遵循 Go 社区最佳实践：显式错误返回、`context.Context` 传递、不可变配置结构体、清晰的接口边界；禁止直接照搬 Python 风格的动态参数或魔法行为到 Go。
- 包内部实现应保持单一职责和稳定接口：对外导出的类型和函数一旦发布，需要通过语义化版本管理变更并提供迁移指南。
- Go 实现不得强制依赖具体的 HTTP 框架、数据库或队列实现；这类依赖应通过接口、适配器或可替换的模块暴露，以便在不同部署环境中灵活组合。

### 跨语言测试纪律与 85%+ 覆盖率

- 测试是行为对齐的主要工具：针对每个被迁移的模块，应在 Python 与 Go 两侧维护对应的测试场景（或共享的契约测试描述），确保关键路径在两种语言下都得到验证。
- Go 侧必须使用标准 `go test` 和表驱动测试模式；对外导出 API 必须有单元测试，重要组合流程需有集成或契约测试。综合覆盖率（按 Go 代码统计）必须达到或超过 85%。
- 推荐引入 “对照测试”（parity tests）：对相同输入，分别调用 Python 与 Go 实现，将输出或中间结果序列化为可比较格式（例如 JSON 或结构化日志），以检测行为差异。
- 任何跳过测试（`t.Skip` 或等价机制）都必须在任务和 PR 描述中说明原因和补救计划；禁止长期存在未解释的跳过。

### 性能与资源使用基线

- Go 迁移的一个核心目标是性能与资源效率；在同等功能下，Go 实现 SHOULD 至少达到 Python 版本的性能表现，且在 CPU 与内存占用上不显著劣于 Python。
- 对关键路径（如模型调用封装、工具执行调度、工作流执行引擎）必须基于基准测试（benchmark）评估 Go 与 Python 的性能差异，并在性能退化时优先优化 Go 实现。
- 对性能敏感的功能（例如并发任务调度、长连接管理、批量 I/O）必须提供基准测试和性能文档，记录测试环境、输入规模和结果，用于指导后续优化与回归检测。

### 安全、配置与 Telemetry

- 所有凭据与敏感配置必须通过环境变量、配置文件或密钥管理系统注入，严禁硬编码到 Go 源码中；需要与 Python 侧的配置约定保持兼容或在文档中清晰对比。
- Go 实现的日志与 Telemetry（如 metrics、traces）应与 Python 版本在语义上保持一致，便于跨语言排障，例如相同的事件名称、标签与错误分类。
- 任何可能影响用户隐私或数据安全的行为（如默认上报 Telemetry、外部网络调用）必须在文档中显式说明，并提供禁用方案；默认配置应倾向于隐私友好。

### 文档与示例对齐

- Go 相关文档和示例必须与 Python 文档保持互补关系：每当 Python 文档新增关键概念（如新的 Agent 类型、工具模式或工作流模式），应评估是否需要 Go 端示例或说明。
- 面向用户的文档必须清晰标注哪些功能在 Go 中可用、哪些仍为 Python-only，并在迁移计划中跟踪缺失部分，避免让用户误以为两边已经完全对齐。
- 示例项目、Cookbook 和 Quickstart 应覆盖 Go 与 Python 两端的典型使用场景（至少一个端到端示例），并标明代码路径、运行命令以及预期输出。

## 技术栈与项目结构

- **语言与运行时**：
  - Python：用于参考实现，当前代码位于 `./agno/`，核心包在 `./agno/libs/agno/agno/`。
  - Go：用于迁移与新实现，代码需集中管理（例如在 `./go/` 或等价目录），并通过 `go.mod` 声明模块路径，且编译产物不得依赖 Python 运行时。
- **测试与工具**：
  - Python 测试使用 `pytest` 等现有工具，沿用上游项目约定。
  - Go 测试使用 `go test`、基准测试以及必要的静态检查工具（如 `golangci-lint`），并通过统一脚本或 Makefile 入口调度。
- **目录与职责**（示例约定，具体由 `plan.md` 落实）：
  - `agno/`：上游 Python 项目镜像，不在本宪章下重构，仅作为规范与回归基线。
  - `go/`（或等价目录）：Go 源码，按领域或模块划分子包，如 `agent`、`models`、`tools`、`workflow`、`os` 等。
  - `specs/`：特性规格与计划（由 speckit 管理），需说明 Python 与 Go 影响面。

## 迁移流程与质量门

1. **分析 Python 行为**
   - 在编写任何 Go 代码前，必须阅读相关 Python 模块、测试与文档，明确要迁移的能力边界、输入输出、错误处理以及依赖关系。
   - 在 `spec.md` 中记录该迁移涉及的 Python 路径（模块、类、函数）和预期使用场景。

2. **设计 Go API 与数据结构**
   - 在 `plan.md` 中描述目标 Go 包、公开 API、主要数据结构和依赖接口，并说明与 Python 抽象的映射关系。
   - 如需对 Python API 做语义调整（例如将动态参数拆解为结构体配置），必须在规格与计划中给出理由与迁移路径。

3. **先写测试再实现**
   - 在 Go 侧先编写失败的单元测试或契约测试，理想情况下可参照 Python 测试用例或从中提炼测试数据。
   - 对于跨语言对照测试，建议首先实现一个最小的桥接层（例如通过 CLI、JSON 文件或 gRPC 调用 Python 实现），用来比对 Go 输出与 Python 结果。

4. **实现与重构**
   - 实现 Go 代码时优先考虑可读性和可测试性，而不是逐行翻译 Python；必要时通过重构 Python 测试或新增规格来澄清模糊行为。
   - 对于共享概念（例如 Agent 生命周期、Session 管理、Tool 调用协议），应在 Go 与 Python 两侧保持统一命名与状态机定义。
   - 交付的 Go 包必须在无 Python 环境下独立运行；如需要跨语言桥接，只能存在于测试或脚本目录，且在发布前确保核心库移除该依赖。

5. **质量门与回归验证**
   - 每个迁移单元（一个包或一组特性）完成后，必须通过：
     - 相关 Go 单元测试与对照测试；
     - Python 侧原有测试（确保未引入对上游行为的误解）；
     - 必要时的性能基准测试。
   - 在 `tasks.md` 中勾选对应任务，并在 PR 描述中链接涉及的 Python 模块、Go 包和测试文件。

## 治理

- 本宪章优先于其他工程规范，并专注于 Python–Go 行为对齐与代码迁移；如与上游 Python 项目的贡献指南或风格约定冲突，应在 RFC 中明确权衡并更新本宪章。
- 修订流程：
  - 提出 RFC，说明变更对 Python 与 Go 两侧行为、测试与文档的影响；
  - 在 speckit 的 plan/spec 中记录治理变更；
  - 同步更新本宪章及相关模板（`plan-template.md`、`spec-template.md`、`tasks-template.md`），并根据影响范围更新版本号：
    - MAJOR：原则删除或重写，导致已有实现需要显著调整；
    - MINOR：新增原则或章节，或显著扩写指南；
    - PATCH：措辞澄清、拼写修复或非语义性微调。
- 合规机制：
  - speckit 生成的 `plan.md` 与 `tasks.md` 必须包含“Python 行为分析”“Go 实现与测试”“跨语言对照测试”等任务；
  - 代码评审需检查是否遵守本宪章的行为对齐、测试与文档要求，并确认没有运行时依赖 Python。

**Version**: 2.1.0 | **Ratified**: 2025-11-18 | **Last Amended**: 2025-11-19
